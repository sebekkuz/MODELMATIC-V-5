import { MinHeap } from './priority-queue';import type{Event,EventKind,SimTime,StationState,Token,EngineConfig,EngineHooks}from'./types';export class Engine{now=0;private seq=0;private heap=new MinHeap<Event>((a,b)=>a.t===b.t?a.seq<b.seq:a.t<b.t);private active=0;private nextOrder=0;constructor(public cfg:EngineConfig,private hooks?:EngineHooks){}schedule(t:SimTime,kind:EventKind,data:any){this.heap.push({t,kind,data,seq:this.seq++});}tryReleases(){const orders=this.cfg.orders;let changed=false;while(this.nextOrder<orders.length){const o=orders[this.nextOrder];if(o.release>this.now)break;const needed=o.funs.length;if(this.active+needed>this.cfg.WIP)break;this.active+=needed;this.nextOrder++;for(const f of o.funs){const tok:Token={prodId:o.id,fun:f,opIdx:0};this.enqueueOrStart(tok);}changed=true;}return changed;}enqueueOrStart(tok:Token){const route=this.cfg.routes[tok.fun];if(!route?.length)return;tok.currentOp=route[tok.opIdx];const tSec=this.cfg.timeMap[tok.fun]?.[tok.currentOp]??0;const elig=this.cfg.able[tok.currentOp]||[];const stId=elig[0];if(!stId)throw new Error(`Brak stacji dla op: ${tok.currentOp}`);const st=this.cfg.stations[stId];const srv=st.busyUntil.findIndex(u=>u<=this.now);if(srv>=0){const finish=this.now+tSec;st.busyUntil[srv]=finish;st.busySum+=tSec;this.schedule(finish,'END_OP',{tok:{...tok},stId,srv});}else{st.queue.push({...tok});}}tryStartFromQueue(stId:string){const st=this.cfg.stations[stId];if(!st)return;for(let i=0;i<st.busyUntil.length;i++){if(st.busyUntil[i]<=this.now&&st.queue.length){const tok=st.queue.shift()!;const tSec=this.cfg.timeMap[tok.fun]?.[tok.currentOp!]??0;const finish=this.now+tSec;st.busyUntil[i]=finish;st.busySum+=tSec;this.schedule(finish,'END_OP',{tok,stId,srv:i});}}}step(){const ev=this.heap.pop();if(!ev)return false;this.now=ev.t;this.hooks?.onEvent?.(ev,this);if(ev.kind==='END_OP'){const tok:Token=ev.data.tok;tok.opIdx++;const route=this.cfg.routes[tok.fun];if(tok.opIdx>=route.length){this.active--;const st=this.cfg.stations[ev.data.stId];if(st)st.doneCount++;}else{this.enqueueOrStart(tok);}this.tryStartFromQueue(ev.data.stId);}this.tryReleases();return true;}run(){this.tryReleases();while(this.heap.size()){this.step();}return this.summary();}summary(){return{time:this.now,stations:Object.fromEntries(Object.entries(this.cfg.stations).map(([id,s])=>[id,{busySum:s.busySum,done:s.doneCount,m:s.m}]))};}}